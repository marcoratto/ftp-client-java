/* Generated By:JavaCC: Do not edit this line. FtpParser.java */
/*
 * Copyright (C) 2011 Marco Ratto
 *
 * This file is part of the project ftp-client-java.
 *
 * ftp-client-java is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * any later version.
 *
 * ftp-client-java is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ftp-client-java; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package uk.co.marcoratto.ftp;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.Vector;
import java.util.Hashtable;
import java.util.StringTokenizer;

import org.apache.log4j.Logger;
import org.apache.commons.io.filefilter.WildcardFileFilter;
import org.apache.commons.net.ftp.FTPFileFilter;
import org.apache.commons.net.ftp.FTPFile;

import uk.co.marcoratto.util.Utility;
import uk.co.marcoratto.net.ClientFTP;
import uk.co.marcoratto.net.ClientFTPException;

public class FtpParser implements FtpParserConstants {

  private final static int DEFAULT_PORT = 21;
  private final static Logger logger = Logger.getLogger("uk.co.marcoratto.ftp");

  private int debugLevel = 0;
  private boolean quoteControlCharacters = false;
  private boolean verbose = false;
  private boolean binary = false;
  private boolean hash = false;
  private boolean prompt = true;
  private boolean passive = false;

  private boolean autoLogin = true;

  private String hostname = null;
  private int port = -1;
  private File localDir = new File(".");
  private File remoteDir = null;

  private String username = null;
  private String password = null;
  private String account = null;

  private boolean connected = false;

  private ClientFTP clientFTP = null;

  private Vector<String> args = new Vector<String>(1);

  private final static Hashtable<String,String> commandHelp = new Hashtable<String,String>();

  static
  {
        commandHelp.put("mdir","list contents of multiple remote directories");
        commandHelp.put("$","execute macro");
        commandHelp.put("sendport","toggle use of PORT cmd for each data connection");
        commandHelp.put("site","send site specific command to remote server");
        commandHelp.put("account","send account command to remote server");
        commandHelp.put("append","append to a file");
        commandHelp.put("mls","list contents of multiple remote directories");
        commandHelp.put("status","show current status");
        commandHelp.put("form","set file transfer format");
        commandHelp.put("mode","set file transfer mode");
        commandHelp.put("struct","set file transfer structure");
        commandHelp.put("bell","beep when command completed");
        commandHelp.put("modtime","show last modification time of remote file");
        commandHelp.put("quote","send arbitrary ftp command");
        commandHelp.put("glob","toggle metacharacter expansion of local file names");
        commandHelp.put("sunique","toggle store unique on remote machine");
        commandHelp.put("newer","get file if remote file is newer than local file ");
        commandHelp.put("reget","get file restarting at end of local file");
        commandHelp.put("tenex","set tenex file transfer type");
        commandHelp.put("case","toggle mget upper/lower case id mapping");
        commandHelp.put("nmap","set templates for default file name mapping");
        commandHelp.put("rstatus","show status of remote machine");
        commandHelp.put("tick","toggle printing byte counter during transfers");
        commandHelp.put("idle","get (set) idle timer on remote side");
        commandHelp.put("trace","toggle packet tracing");
        commandHelp.put("cdup","change remote working directory to parent directory");
        commandHelp.put("ntrans","set translation table for default file name mapping");
        commandHelp.put("chmod","change file permissions of remote file");
        commandHelp.put("reset","clear queued command replies");
        commandHelp.put("restart","restart file transfer at bytecount");
        commandHelp.put("umask","get (set) umask on remote side");
        commandHelp.put("cr","toggle carriage return stripping on ascii gets");
        commandHelp.put("macdef","define a macro");
        commandHelp.put("mdelete","delete multiple files");
        commandHelp.put("proxy","issue command on alternate connection");
        commandHelp.put("runique","toggle store unique for local files");
  }

  private String help = "!\u0009\u0009debug\u0009\u0009mdir\u0009\u0009qc\u0009\u0009send"
                                 + "\u005cn"
                                 + "$\u0009\u0009dir\u0009\u0009mget\u0009\u0009sendport\u0009site"
                                 + "\u005cn"
                                 + "account\u0009\u0009disconnect\u0009mkdir\u0009\u0009put\u0009\u0009size"
                                 + "\u005cn"
                                 + "append\u0009\u0009exit\u0009\u0009mls\u0009\u0009pwd\u0009\u0009status"
                                 + "\u005cn"
                                 + "ascii\u0009\u0009form\u0009\u0009mode\u0009\u0009quit\u0009\u0009struct"
                                 + "\u005cn"
                                 + "bell\u0009\u0009get\u0009\u0009modtime\u0009\u0009quote\u0009\u0009system"
                                 + "\u005cn"
                                 + "binary\u0009\u0009glob\u0009\u0009mput\u0009\u0009recv\u0009\u0009sunique"
                                 + "\u005cn"
                                 + "bye\u0009\u0009hash\u0009\u0009newer\u0009\u0009reget\u0009\u0009tenex"
                                 + "\u005cn"
                                 + "case\u0009\u0009help\u0009\u0009nmap\u0009\u0009rstatus\u0009\u0009tick"
                                 + "\u005cn"
                                 + "cd\u0009\u0009idle\u0009\u0009nlist\u0009\u0009rhelp\u0009\u0009trace"
                                 + "\u005cn"
                                 + "cdup\u0009\u0009image\u0009\u0009ntrans\u0009\u0009rename\u0009\u0009type"
                                 + "\u005cn"
                                 + "chmod\u0009\u0009lcd\u0009\u0009open\u0009\u0009reset\u0009\u0009user"
                                 + "\u005cn"
                                 + "close\u0009\u0009ls\u0009\u0009prompt\u0009\u0009restart\u0009\u0009umask"
                                 + "\u005cn"
                                 + "cr\u0009\u0009macdef\u0009\u0009passive\u0009\u0009rmdir\u0009\u0009verbose"
                                 + "\u005cn"
                                 + "delete\u0009\u0009mdelete\u0009\u0009proxy\u0009\u0009runique\u0009\u0009?";


  public void setAutoLogin(boolean b) {
    this.autoLogin = b;
  }

  public boolean getAutoLogin() {
    return this.autoLogin;
  }

  public void setPassive(boolean b) {
    this.passive = b;
  }

  public boolean getPassive() {
    return this.passive;
  }

  private void help(String cmd) {
         String msg = "unknown";
         if (commandHelp.containsKey(cmd)) {
                msg = commandHelp.get(cmd);
         }
        System.out.println(cmd + "\u005ct" + msg);
  }

  private void help() {
   System.out.println(help);
  }

  private void dologout(int i){
    System.exit(i);
  }

  private void reply(int i, String s) {
    System.out.println(i + " " + s);
  }

  private void commandCD() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String directory = null;
     if (args.size() == 0) {
            directory = Utility.input("(remote-directory):", "");
     } else {
       directory = args.get(0);
     }
     if ((directory == null) && directory.trim().length() != 0) {
       System.out.println("usage: cd remote-directory");
     } else{
                try {
                clientFTP.cwd(directory);
                this.remoteDir = clientFTP.getRemoteDirectory();
                } catch (ClientFTPException e) {
                  logger.error(e.getMessage(), e);
                }
     }
  }

  private void commandLCD() {
     if (args.size() > 0) {
         if (args.get(0).startsWith("/")) {
                        localDir = new File(args.get(0));
         } else {
           localDir = new File(localDir, args.get(0));
         }
    }
    try {
                System.out.println("Local directory now " + localDir.getCanonicalPath());
        } catch (IOException e) {
          logger.error(e.getMessage(), e);
        }

  }

  private void commandMKDIR() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String directory = null;
     if (args.size() == 0) {
            directory = Utility.input("(directory-name):", "");
     } else {
       directory = args.get(0);
     }
     if ((directory == null) && directory.trim().length() != 0) {
       System.out.println("usage: mkdir directory-name");
     } else{
                try {
                clientFTP.mkdir(directory);
                } catch (ClientFTPException e) {
                  logger.error(e);
                }
     }
  }

  private void commandRMDIR() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String directory = null;
     if (args.size() == 0) {
            directory = Utility.input("(directory-name):", "");
     } else {
       directory = args.get(0);
     }
     if ((directory == null) && directory.trim().length() != 0) {
       System.out.println("usage: rmdir directory-name");
     } else{
                try {
                clientFTP.rmdir(directory);
                } catch (ClientFTPException e) {
                  logger.error(e.getMessage(), e);
                }
     }
  }

  private void commandDELETE() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String remoteFile = null;
     if (args.size() == 0) {
            remoteFile = Utility.input("(remote-file):", "");
     } else {
       remoteFile = args.get(0);
     }
     if ((remoteFile == null) && remoteFile.trim().length() != 0) {
       System.out.println("usage: delete remote-file");
     } else{
                try {
                clientFTP.deleteFile(remoteFile);
                } catch (ClientFTPException e) {
                  logger.error(e.getMessage(), e);
                }
     }
  }

  private void commandRENAME() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String fromName = null;
     String toName = null;
     if (args.size() == 0) {
            fromName = Utility.input("(from-name)", "");
            toName = Utility.input("(to-name)", "");
     } else {
       fromName = args.get(0);
       toName = args.get(1);
     }
     if (((fromName == null) && fromName.trim().length() != 0) ||
         ((toName == null) && toName.trim().length() != 0)) {
       System.out.println("usage: rename from-name to-name");
     } else{
                try {
                clientFTP.rename(fromName, toName);
                } catch (ClientFTPException e) {
                  logger.error(e.getMessage(), e);
                }
     }
  }

  private void commandPUT() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String localFileFilter = null;
     String localFile = null;
     String remoteFile = null;
     if (args.size() == 0) {
            localFileFilter = Utility.input("(local-file):", "");
            remoteFile = Utility.input("(remote-file):", "");
     } else if (args.size() == 1) {
       localFileFilter = args.get(0);
     } else {
       localFileFilter = args.get(0);
       remoteFile = args.get(1);
     }
     logger.info("localDir=" + this.localDir);
     logger.info("localFileFilter=" + localFileFilter);
         FileFilter fileFilter = new WildcardFileFilter(localFileFilter);
         File[] files = this.localDir.listFiles(fileFilter);
     logger.info("Found " + files.length + " files.");
         if (files.length == 0) {
           System.out.println("local: " + localFileFilter + ": No such file or directory");
           return;
         }

        localFile = files[0].getName();

        if (remoteFile == null) {
          remoteFile = localFile;
        }

     // localFile = Utility.concatenate(this.localDir, localFile);
     if (((localFile == null) && localFile.trim().length() != 0) ||
         ((remoteFile == null) && remoteFile.trim().length() != 0)) {
       System.out.println("usage: send local-file remote-file");
       return;
     }
     this.upload(localFile, remoteFile);
  }

  private void commandMPUT() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String localFiles = "";
     String remoteFile = null;
     if (args.size() == 0) {
            localFiles = Utility.input("(local-files):", "");
     } else {
       String sep = "";
       for (int j=0; j<args.size(); j++) {
                localFiles += sep + args.get(j);
                sep = " ";
       }
     }
     logger.info("localFiles=" + localFiles);
     StringTokenizer st = new StringTokenizer(localFiles, " ");
     String localFileFilter = null;

     while (st.hasMoreElements()) {
         localFileFilter = (String) st.nextElement();
             logger.info("localFileFilter=" + localFileFilter);
                 FileFilter fileFilter = new WildcardFileFilter(localFileFilter);
                 File[] files = this.localDir.listFiles(fileFilter);
         logger.info("Found " + files.length + " files.");
         for (int j=0; j<files.length; j++) {
           String localFile = files[j].getName();
           remoteFile = localFile;
           if (this.prompt) {
                                String yesOrNot = Utility.input("mput " + localFile + "?", "");
                                if (!(yesOrNot.trim().equalsIgnoreCase("n")) &&
                                   (!yesOrNot.trim().equalsIgnoreCase("no"))) {
                           this.upload(localFile, remoteFile);
                                }
           } else {
               this.upload(localFile, remoteFile);
           }
         }
         }
  }

  private void upload(String local, String remote) {
    local = Utility.concatenate(localDir, local);
    remote = Utility.concatenate(remoteDir, remote);

            System.out.println("local: " + local + " remote: " + remote);
            if (!Utility.checkFile(local)) {
              System.out.println("local: " + local + ": No such file or directory");
              return;
            }
                try {
                    long startTime = System.currentTimeMillis();
                clientFTP.upload(local, remote);
                long endTime = System.currentTimeMillis();
                long delay = endTime-startTime;

                long fileSize = Utility.getFileSize(local);
                        double average = fileSize / delay * 1000;
                System.out.println(fileSize + " bytes sent in " + Utility.msToSecondss(delay) + " secs (" + Utility.formatDouble("0.0", average) + " kB/s)");
                } catch (ClientFTPException e) {
                  logger.error(e);
                }
  }

  private void commandGET() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String localFile = null;
     String remoteFile = null;
     if (args.size() == 0) {
            remoteFile = Utility.input("(remote-file):", "");
            localFile = Utility.input("(local-file):", "");
     } else if (args.size() == 1) {
       remoteFile = args.get(0);
     } else {
       remoteFile = args.get(0);
       localFile = args.get(1);
     }
     logger.info("localDir=" + this.localDir);
     logger.info("remoteDir=" + this.remoteDir);

        if (localFile == null) {
          localFile = remoteFile;
        }

     if (((localFile == null) || localFile.trim().length() == 0) ||
         ((remoteFile == null) || remoteFile.trim().length() == 0)) {
       System.out.println("usage: get remote-file [local-file]");
       return;
     }
     this.download(localFile, remoteFile);
  }

  private void download(String local, String remote) {
    local = Utility.concatenate(localDir, local);
    remote = Utility.concatenate(remoteDir, remote);

            System.out.println("remote:" + remote + " local:" + local);
                try {
                    long startTime = System.currentTimeMillis();
                boolean returnFlag = clientFTP.downloadFile(remote, local);
                if (returnFlag) {
                        long endTime = System.currentTimeMillis();
                        long delay = endTime-startTime;

                        long fileSize = Utility.getFileSize(local);
                                double average = fileSize / delay * 1000;
                        System.out.println(fileSize + " bytes received in " + Utility.msToSecondss(delay) + " secs (" + Utility.formatDouble("0.0", average) + " kB/s)");
                }
                } catch (ClientFTPException e) {
                        logger.error(e.getMessage(), e);
                }
  }

    private void commandLS() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String directory = null;
     if (args.size() >= 1) {
       directory = args.get(0);
     }
        try {
                clientFTP.ls(directory);
        } catch (ClientFTPException e) {
          logger.error(e);
        }
  }

    private void commandNLIST() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String directory = null;
     if (args.size() >= 1) {
       directory = args.get(0);
     }
        try {
                clientFTP.nlist(directory);
        } catch (ClientFTPException e) {
          logger.error(e);
        }
  }

    private void commandMGET() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String directory = null;
     if (args.size() >= 1) {
       directory = args.get(0);
     }
        try {
                FTPFile[] files = clientFTP.getRemoteFiles(directory);
                for (int i = 0; i < files.length; i++) {
                  this.reply(150, "Opening " + Utility.translateBinary(this.binary) + " mode data connection for " + files[i].getName() + "(" + files[i].getSize()+ " bytes).");
           if (this.prompt) {
                                String yesOrNot = Utility.input("mget " + files[i].getName() + "?", "");
                                if (!(yesOrNot.trim().equalsIgnoreCase("n")) &&
                                   (!yesOrNot.trim().equalsIgnoreCase("no"))) {
                                   this.download(files[i].getName(), files[i].getName());
                                }
           } else {
                           this.download(files[i].getName(), files[i].getName());
           }

                }
        } catch (ClientFTPException e) {
          logger.error(e);
        }
  }

  private void commandSIZE() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
     String filename = null;
     if (args.size() == 0) {
       filename = Utility.input("(remote-file):", "");
         } else {
       filename = args.get(0);
     }

     if ((filename == null) || (filename.trim().length() == 0)) {
       System.out.println("usage: size filename");
       return;
     }
        try {
                long l = clientFTP.size(Utility.concatenate(remoteDir, filename));
                if (l == -1) {
                  reply(550, "Could not get file size.");
                } else {
                  reply(213, Long.toString(l));
                }
        } catch (ClientFTPException e) {
          logger.error(e);
        }
  }

  private void commandPWD() {
     if (!connected) {
       System.out.println("Not connected!");
       return;
     }
        try {
                clientFTP.pwd();
        } catch (ClientFTPException e) {
          logger.error(e);
        }
  }

  private void commandCLOSE() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
                try {
                        clientFTP.disconnect();
                } catch (ClientFTPException e) {
                  logger.error(e);
                }
                clientFTP = null;
                connected = false;
  }

  private void commandRHELP() {
     if (!connected) {
       System.out.println("Not connected.");
       return;
     }
        try {
                clientFTP.rhelp();
        } catch (ClientFTPException e) {
          logger.error(e);
        }
  }

  private void commandUSER() {
        username = null;
        password = null;
        account = null;
        switch (args.size()) {
        case 3:
                username = args.get(0);
                password = args.get(1);
                account = args.get(2);
                break;
        case 2:
                username = args.get(0);
                password = args.get(1);
                break;
        case 1:
            username = args.get(0);
                break;
        case 0:
                username = Utility.input("(username)", (String) null);
                break;

        default:
                break;
        }

    if ((username == null) || (username.trim().length() == 0)) {
          System.out.println("usage: user username [password] [account]");
    }

  }

  private void commandTYPE() {
     if (!connected) {
       System.out.println("Not connected!");
       return;
     }
     if (binary) {
       System.out.println("Using binary mode to transfer files.");
     } else {
       System.out.println("Using ascii mode to transfer files.");
     }
  }

  private void commandHELP(String s) {
        logger.info("HELP:" + s);
    if (s != null) {
      System.out.println(s);
    } else {
      System.out.println("unknown.");
    }
  }

  private void commandQUIT() {
        logger.info("QUIT");
    if (connected) {
                reply(221, "Goodbye.");
        }
    dologout(0);
  }

  private void commandPASSIVE() {
     if (!connected) {
       System.out.println("Not connected!");
       return;
     }
     passive = !passive;
     clientFTP.setPassiveMode(passive);
     System.out.println("Passive mode " + Utility.translateBooleanToOnOff(passive) + ".");
  }

  private void commandPROMPT() {
     prompt = !prompt;
     System.out.println("Interactive mode " + Utility.translateBooleanToOnOff(prompt) + ".");
  }

  private void commandHASH() {
     hash = !hash;
     System.out.println("Hash mark printing " + Utility.translateBooleanToOnOff(hash) +
                                    (hash ? " (1024 bytes/hash mark)." : "."));
  }

  private void commandBINARY() {
     if (!connected) {
       System.out.println("Not connected!");
       return;
     }
        try {
     clientFTP.setFileTypeBINARY();
     binary = true;
        } catch (ClientFTPException e) {
          logger.error(e.getMessage(), e);
        }
  }

  private void commandASCII() {
     if (!connected) {
       System.out.println("Not connected!");
       return;
     }
     try {
        clientFTP.setFileTypeASCII();
            binary = false;
         } catch (ClientFTPException e) {
                logger.error(e.getMessage(), e);
         }
  }

  private void commandVERBOSE() {
     verbose = !verbose;
     System.out.println("Verbose mode " + Utility.translateBooleanToOnOff(verbose) + ".");
  }

  private void commandDEBUG() {
     int i = -1;
     if (args.size() >= 1) {
       i = Utility.stringToIntegerValue(args.get(0), -1);
    }
    if (i == -1) {
      System.out.println(args.get(0) + ": bad debugging value.");
      return;
        }
    debugLevel = i;
    System.out.println("Debugging " + Utility.translateIntegerValueToOnOff(debugLevel) + "(debug=" + debugLevel + ").");
  }

  private void commandOPEN() {
     if (connected) {
       System.out.println("Already connected to " + this.hostname + ", use close first.");
       return;
     }
     logger.debug("args.size()=" + args.size());
     if (args.size() == 0) {
       this.hostname = Utility.input("(to)", "");
       this.port = DEFAULT_PORT;
     } else if (args.size() == 1) {
       this.hostname = args.get(0);
       this.port = DEFAULT_PORT;
     } else if (args.size() >= 2) {
       this.hostname = args.get(0);
           this.port = Utility.stringToIntegerValue(args.get(1), -1);
     } else {
        System.out.println("usage: open host-name [port]");
        return;
     }
         if (this.port == -1) {
            System.out.println(args.get(1) + ": bad debugging value.");
         }
     if ((hostname==null) ||
         (hostname.trim().length() == 0) ||
         (this.port == -1)) {
          System.out.println("usage: open host-name [port]");
          return;
     }

     if (Utility.checkHostname(this.hostname) == false) {
       System.out.println("ftp: " + this.hostname + ": Unknown host");
       return;
     }

        clientFTP = new ClientFTP();
                try {
                clientFTP.connect(hostname, port);
                System.out.println("Connected to " + hostname);
                clientFTP.printReplyStrings();

                if (autoLogin) {
                                username = Utility.getDefaultUser();
                        username = Utility.input("Name (" + hostname + ":" + username + "):", username);
                        password = Utility.input("Password:", "");
                        clientFTP.login(username, password, account);
                }

                this.remoteDir = clientFTP.getRemoteDirectory();
                logger.info("remoteDir=" + this.remoteDir);

                connected = true;
                } catch (ClientFTPException e) {
                  logger.error(e.getMessage(), e);
                }

  }

  final public void cmd_list() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SPACE:
    case CRLF:
    case HELP:
    case BANG:
    case CD:
    case LCD:
    case LS:
    case QC:
    case QUIT:
    case MKDIR:
    case RMDIR:
    case PUT:
    case DELETE:
    case MPUT:
    case GET:
    case MGET:
    case RENAME:
    case SIZE:
    case NLIST:
    case USER:
    case PASSIVE:
    case PROMPT:
    case HASH:
    case BINARY:
    case ASCII:
    case VERBOSE:
    case DEBUG:
    case OPEN:
    case CLOSE:
    case TYPE:
    case PWD:
    case RHELP:
    case SYSTEM:
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        jj_consume_token(SPACE);
      }
      cmd();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        jj_consume_token(SPACE);
      }
      jj_consume_token(CRLF);

      break;
    case RNFR:
      rcmd();
      jj_consume_token(38);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void cmd() throws ParseException {
  int tmpIntegerValue = 0;
  String a = null;
  args = new Vector<String>(1);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CRLF:
      jj_consume_token(CRLF);
      break;
    default:
      jj_la1[21] = jj_gen;
      if (jj_2_1(2)) {
        jj_consume_token(USER);
        label_3:
        while (true) {
          jj_consume_token(SPACE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SPACE:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_3;
          }
        }
        argList();
        this.commandUSER();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case USER:
          jj_consume_token(USER);
        this.commandUSER();
          break;
        default:
          jj_la1[22] = jj_gen;
          if (jj_2_2(2)) {
            jj_consume_token(HELP);
            label_4:
            while (true) {
              jj_consume_token(SPACE);
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case SPACE:
                ;
                break;
              default:
                jj_la1[4] = jj_gen;
                break label_4;
              }
            }
            a = tokenCommand();
        this.commandHELP(a);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case HELP:
              jj_consume_token(HELP);
                logger.info("HELP");
        help();
              break;
            case QUIT:
              jj_consume_token(QUIT);
          this.commandQUIT();
              break;
            default:
              jj_la1[23] = jj_gen;
              if (jj_2_3(2)) {
                jj_consume_token(LCD);
                label_5:
                while (true) {
                  jj_consume_token(SPACE);
                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                  case SPACE:
                    ;
                    break;
                  default:
                    jj_la1[5] = jj_gen;
                    break label_5;
                  }
                }
                argList();
      this.commandLCD();
              } else {
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case LCD:
                  jj_consume_token(LCD);
      this.commandLCD();
                  break;
                default:
                  jj_la1[24] = jj_gen;
                  if (jj_2_4(2)) {
                    jj_consume_token(BANG);
                    label_6:
                    while (true) {
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case SPACE:
                        ;
                        break;
                      default:
                        jj_la1[6] = jj_gen;
                        break label_6;
                      }
                      jj_consume_token(SPACE);
                    }
                    argList();
     Utility.exec(args.get(0));
                  } else {
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case BANG:
                      jj_consume_token(BANG);
     Utility.execShell();
                      break;
                    case PASSIVE:
                      jj_consume_token(PASSIVE);
     this.commandPASSIVE();
                      break;
                    case PROMPT:
                      jj_consume_token(PROMPT);
     this.commandPROMPT();
                      break;
                    case HASH:
                      jj_consume_token(HASH);
     this.commandHASH();
                      break;
                    case BINARY:
                      jj_consume_token(BINARY);
     this.commandBINARY();
                      break;
                    case ASCII:
                      jj_consume_token(ASCII);
     this.commandASCII();
                      break;
                    case TYPE:
                      jj_consume_token(TYPE);
     this.commandTYPE();
                      break;
                    case VERBOSE:
                      jj_consume_token(VERBOSE);
     this.commandVERBOSE();
                      break;
                    case QC:
                      jj_consume_token(QC);
     quoteControlCharacters = !quoteControlCharacters;
     System.out.println("Quote control characters " + Utility.translateBooleanToOnOff(quoteControlCharacters) + ".");
                      break;
                    default:
                      jj_la1[25] = jj_gen;
                      if (jj_2_5(2)) {
                        jj_consume_token(DEBUG);
                        label_7:
                        while (true) {
                          jj_consume_token(SPACE);
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case SPACE:
                            ;
                            break;
                          default:
                            jj_la1[7] = jj_gen;
                            break label_7;
                          }
                        }
                        argList();
     this.commandDEBUG();
                      } else {
                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case DEBUG:
                          jj_consume_token(DEBUG);
     debugLevel=1;
     System.out.println("Debugging " + Utility.translateIntegerValueToOnOff(debugLevel) + "(debug=" + debugLevel + ").");
                          break;
                        default:
                          jj_la1[26] = jj_gen;
                          if (jj_2_6(2)) {
                            jj_consume_token(OPEN);
                            label_8:
                            while (true) {
                              jj_consume_token(SPACE);
                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                              case SPACE:
                                ;
                                break;
                              default:
                                jj_la1[8] = jj_gen;
                                break label_8;
                              }
                            }
                            argList();
     this.commandOPEN();
                          } else {
                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                            case OPEN:
                              jj_consume_token(OPEN);
     this.commandOPEN();
                              break;
                            case CLOSE:
                              jj_consume_token(CLOSE);
     this.commandCLOSE();
                              break;
                            case PWD:
                              jj_consume_token(PWD);
     this.commandPWD();
                              break;
                            default:
                              jj_la1[27] = jj_gen;
                              if (jj_2_7(2)) {
                                jj_consume_token(CD);
                                label_9:
                                while (true) {
                                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                  case SPACE:
                                    ;
                                    break;
                                  default:
                                    jj_la1[9] = jj_gen;
                                    break label_9;
                                  }
                                  jj_consume_token(SPACE);
                                }
                                argList();
     this.commandCD();
                              } else {
                                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                case CD:
                                  jj_consume_token(CD);
     this.commandCD();
                                  break;
                                default:
                                  jj_la1[28] = jj_gen;
                                  if (jj_2_8(2)) {
                                    jj_consume_token(MKDIR);
                                    label_10:
                                    while (true) {
                                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                      case SPACE:
                                        ;
                                        break;
                                      default:
                                        jj_la1[10] = jj_gen;
                                        break label_10;
                                      }
                                      jj_consume_token(SPACE);
                                    }
                                    argList();
     this.commandMKDIR();
                                  } else {
                                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                    case MKDIR:
                                      jj_consume_token(MKDIR);
     this.commandMKDIR();
                                      break;
                                    default:
                                      jj_la1[29] = jj_gen;
                                      if (jj_2_9(2)) {
                                        jj_consume_token(RMDIR);
                                        label_11:
                                        while (true) {
                                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                          case SPACE:
                                            ;
                                            break;
                                          default:
                                            jj_la1[11] = jj_gen;
                                            break label_11;
                                          }
                                          jj_consume_token(SPACE);
                                        }
                                        argList();
     this.commandRMDIR();
                                      } else {
                                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                        case RMDIR:
                                          jj_consume_token(RMDIR);
     this.commandRMDIR();
                                          break;
                                        default:
                                          jj_la1[30] = jj_gen;
                                          if (jj_2_10(2)) {
                                            jj_consume_token(DELETE);
                                            label_12:
                                            while (true) {
                                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                              case SPACE:
                                                ;
                                                break;
                                              default:
                                                jj_la1[12] = jj_gen;
                                                break label_12;
                                              }
                                              jj_consume_token(SPACE);
                                            }
                                            argList();
     this.commandDELETE();
                                          } else {
                                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                            case DELETE:
                                              jj_consume_token(DELETE);
     this.commandDELETE();
                                              break;
                                            default:
                                              jj_la1[31] = jj_gen;
                                              if (jj_2_11(2)) {
                                                jj_consume_token(RENAME);
                                                label_13:
                                                while (true) {
                                                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                  case SPACE:
                                                    ;
                                                    break;
                                                  default:
                                                    jj_la1[13] = jj_gen;
                                                    break label_13;
                                                  }
                                                  jj_consume_token(SPACE);
                                                }
                                                argList();
     this.commandRENAME();
                                              } else {
                                                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                case RENAME:
                                                  jj_consume_token(RENAME);
     this.commandRENAME();
                                                  break;
                                                default:
                                                  jj_la1[32] = jj_gen;
                                                  if (jj_2_12(2)) {
                                                    jj_consume_token(LS);
                                                    label_14:
                                                    while (true) {
                                                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                      case SPACE:
                                                        ;
                                                        break;
                                                      default:
                                                        jj_la1[14] = jj_gen;
                                                        break label_14;
                                                      }
                                                      jj_consume_token(SPACE);
                                                    }
                                                    argList();
     this.commandLS();
                                                  } else {
                                                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                    case LS:
                                                      jj_consume_token(LS);
     this.commandLS();
                                                      break;
                                                    default:
                                                      jj_la1[33] = jj_gen;
                                                      if (jj_2_13(2)) {
                                                        jj_consume_token(NLIST);
                                                        label_15:
                                                        while (true) {
                                                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                          case SPACE:
                                                            ;
                                                            break;
                                                          default:
                                                            jj_la1[15] = jj_gen;
                                                            break label_15;
                                                          }
                                                          jj_consume_token(SPACE);
                                                        }
                                                        argList();
     this.commandNLIST();
                                                      } else {
                                                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                        case NLIST:
                                                          jj_consume_token(NLIST);
     this.commandNLIST();
                                                          break;
                                                        default:
                                                          jj_la1[34] = jj_gen;
                                                          if (jj_2_14(2)) {
                                                            jj_consume_token(PUT);
                                                            label_16:
                                                            while (true) {
                                                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                              case SPACE:
                                                                ;
                                                                break;
                                                              default:
                                                                jj_la1[16] = jj_gen;
                                                                break label_16;
                                                              }
                                                              jj_consume_token(SPACE);
                                                            }
                                                            argList();
     this.commandPUT();
                                                          } else {
                                                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                            case PUT:
                                                              jj_consume_token(PUT);
     this.commandPUT();
                                                              break;
                                                            default:
                                                              jj_la1[35] = jj_gen;
                                                              if (jj_2_15(2)) {
                                                                jj_consume_token(MPUT);
                                                                label_17:
                                                                while (true) {
                                                                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                  case SPACE:
                                                                    ;
                                                                    break;
                                                                  default:
                                                                    jj_la1[17] = jj_gen;
                                                                    break label_17;
                                                                  }
                                                                  jj_consume_token(SPACE);
                                                                }
                                                                argList();
     this.commandMPUT();
                                                              } else {
                                                                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                case MPUT:
                                                                  jj_consume_token(MPUT);
     this.commandMPUT();
                                                                  break;
                                                                default:
                                                                  jj_la1[36] = jj_gen;
                                                                  if (jj_2_16(2)) {
                                                                    jj_consume_token(GET);
                                                                    label_18:
                                                                    while (true) {
                                                                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                      case SPACE:
                                                                        ;
                                                                        break;
                                                                      default:
                                                                        jj_la1[18] = jj_gen;
                                                                        break label_18;
                                                                      }
                                                                      jj_consume_token(SPACE);
                                                                    }
                                                                    argList();
     this.commandGET();
                                                                  } else {
                                                                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                    case GET:
                                                                      jj_consume_token(GET);
     this.commandGET();
                                                                      break;
                                                                    default:
                                                                      jj_la1[37] = jj_gen;
                                                                      if (jj_2_17(2)) {
                                                                        jj_consume_token(MGET);
                                                                        label_19:
                                                                        while (true) {
                                                                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                          case SPACE:
                                                                            ;
                                                                            break;
                                                                          default:
                                                                            jj_la1[19] = jj_gen;
                                                                            break label_19;
                                                                          }
                                                                          jj_consume_token(SPACE);
                                                                        }
                                                                        argList();
     this.commandMGET();
                                                                      } else {
                                                                        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                        case MGET:
                                                                          jj_consume_token(MGET);
     this.commandMGET();
                                                                          break;
                                                                        default:
                                                                          jj_la1[38] = jj_gen;
                                                                          if (jj_2_18(2)) {
                                                                            jj_consume_token(SIZE);
                                                                            label_20:
                                                                            while (true) {
                                                                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                              case SPACE:
                                                                                ;
                                                                                break;
                                                                              default:
                                                                                jj_la1[20] = jj_gen;
                                                                                break label_20;
                                                                              }
                                                                              jj_consume_token(SPACE);
                                                                            }
                                                                            argList();
     this.commandSIZE();
                                                                          } else {
                                                                            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                                                                            case SIZE:
                                                                              jj_consume_token(SIZE);
     this.commandSIZE();
                                                                              break;
                                                                            case RHELP:
                                                                              jj_consume_token(RHELP);
     this.commandRHELP();
                                                                              break;
                                                                            case SYSTEM:
                                                                              jj_consume_token(SYSTEM);
     if (!connected) {
       System.out.println("Not connected!");
       {if (true) return;}
     }
                try {
                clientFTP.system();
                } catch (ClientFTPException e) {
                  logger.error(e);
                }
                                                                              break;
                                                                            default:
                                                                              jj_la1[39] = jj_gen;
                                                                              jj_consume_token(-1);
                                                                              throw new ParseException();
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  final public void rcmd() throws ParseException {
    jj_consume_token(RNFR);
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_21;
      }
      jj_consume_token(SPACE);
    }
    argList();

  }

  final public String tokenCommand() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HELP:
      t = jj_consume_token(HELP);
                {if (true) return t.toString().trim() + "\u005ctprint local help information";}
      break;
    case USER:
      t = jj_consume_token(USER);
                {if (true) return t.toString().trim() + "\u005ctsend new user information";}
      break;
    case QUIT:
      t = jj_consume_token(QUIT);
                {if (true) return t.toString().trim() + "\u005ctterminate ftp session and exit";}
      break;
    case LCD:
      t = jj_consume_token(LCD);
                {if (true) return t.toString().trim() + "\u005ctchange local working directory";}
      break;
    case BANG:
      t = jj_consume_token(BANG);
                {if (true) return t.toString().trim() + "\u005ctescape to the shell";}
      break;
    case PASSIVE:
      t = jj_consume_token(PASSIVE);
                {if (true) return t.toString().trim() + "\u005ctenter passive transfer mode";}
      break;
    case PROMPT:
      t = jj_consume_token(PROMPT);
                {if (true) return t.toString().trim() + "\u005ctforce interactive prompting on multiple commands";}
      break;
    case HASH:
      t = jj_consume_token(HASH);
                {if (true) return t.toString().trim() + "\u005cttoggle printing '#' for each buffer transferred";}
      break;
    case BINARY:
      t = jj_consume_token(BINARY);
                {if (true) return t.toString().trim() + "\u005ctset binary transfer type";}
      break;
    case ASCII:
      t = jj_consume_token(ASCII);
                {if (true) return t.toString().trim() + "\u005ctset ascii transfer type";}
      break;
    case VERBOSE:
      t = jj_consume_token(VERBOSE);
                {if (true) return t.toString().trim() + "\u005cttoggle verbose mode";}
      break;
    case QC:
      t = jj_consume_token(QC);
                {if (true) return t.toString().trim() + "\u005ctprint ? in place of control characters on stdout";}
      break;
    case DEBUG:
      t = jj_consume_token(DEBUG);
          {if (true) return t.toString().trim() + "\u005cttoggle/set debugging mode";}
      break;
    case OPEN:
      t = jj_consume_token(OPEN);
          {if (true) return t.toString().trim() + "\u005ctconnect to remote ftp";}
      break;
    case CLOSE:
      t = jj_consume_token(CLOSE);
         {if (true) return t.toString().trim() + "\u005ctterminate ftp session";}
      break;
    case TYPE:
      t = jj_consume_token(TYPE);
          {if (true) return t.toString().trim() + "\u005ctset file transfer type";}
      break;
    case PWD:
      t = jj_consume_token(PWD);
          {if (true) return t.toString().trim() + "\u005ctprint working directory on remote machine";}
      break;
    case SYSTEM:
      t = jj_consume_token(SYSTEM);
          {if (true) return t.toString().trim() + "\u005ctshow remote system type";}
      break;
    case CD:
      t = jj_consume_token(CD);
          {if (true) return t.toString().trim() + "\u005ctchange remote working directory";}
      break;
    case MKDIR:
      t = jj_consume_token(MKDIR);
          {if (true) return t.toString().trim() + "\u005ctmake directory on the remote machine";}
      break;
    case RMDIR:
      t = jj_consume_token(RMDIR);
          {if (true) return t.toString().trim() + "\u005ctremove directory on the remote machine";}
      break;
    case LS:
      t = jj_consume_token(LS);
          {if (true) return t.toString().trim() + "\u005ctlist contents of remote directory";}
      break;
    case PUT:
      t = jj_consume_token(PUT);
          {if (true) return t.toString().trim() + "\u005ctsend one file";}
      break;
    case MPUT:
      t = jj_consume_token(MPUT);
          {if (true) return t.toString().trim() + "\u005ctsend multiple files";}
      break;
    case DELETE:
      t = jj_consume_token(DELETE);
          {if (true) return t.toString().trim() + "\u005ctdelete remote file";}
      break;
    case RENAME:
      t = jj_consume_token(RENAME);
          {if (true) return t.toString().trim() + "\u005ctrename file";}
      break;
    case RHELP:
      t = jj_consume_token(RHELP);
          {if (true) return t.toString().trim() + "\u005ctget help from remote server";}
      break;
    case NLIST:
      t = jj_consume_token(NLIST);
          {if (true) return t.toString().trim() + "\u005ctnlist contents of remote directory";}
      break;
    case GET:
      t = jj_consume_token(GET);
          {if (true) return t.toString().trim() + "\u005ctnreceive file";}
      break;
    case SIZE:
      t = jj_consume_token(SIZE);
          {if (true) return t.toString().trim() + "\u005ctshow size of remote file";}
      break;
    case MGET:
      t = jj_consume_token(MGET);
          {if (true) return t.toString().trim() + "\u005ctget multiple files";}
      break;
    default:
      jj_la1[41] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void argList() throws ParseException {
  args = new Vector<String>(1);
    arg();
    label_22:
    while (true) {
      if (jj_2_19(2)) {
        ;
      } else {
        break label_22;
      }
      label_23:
      while (true) {
        jj_consume_token(SPACE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_23;
        }
      }
      arg();
    }
  }

  final public void arg() throws ParseException {
  Token t = null;
    t = jj_consume_token(STRING);
  args.add(t.toString().trim());
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_3R_25() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3_19() {
    Token xsp;
    if (jj_scan_token(3)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(BANG)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_scan_token(GET)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_scan_token(DELETE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(DEBUG)) return true;
    Token xsp;
    if (jj_scan_token(3)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(LCD)) return true;
    Token xsp;
    if (jj_scan_token(3)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_15() {
    if (jj_scan_token(MPUT)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_scan_token(RMDIR)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_scan_token(PUT)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_scan_token(MKDIR)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(HELP)) return true;
    Token xsp;
    if (jj_scan_token(3)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(USER)) return true;
    Token xsp;
    if (jj_scan_token(3)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_13() {
    if (jj_scan_token(NLIST)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_scan_token(CD)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_scan_token(SIZE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_scan_token(LS)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_scan_token(MGET)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_scan_token(RENAME)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(OPEN)) return true;
    Token xsp;
    if (jj_scan_token(3)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(3)) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** Generated Token Manager. */
  public FtpParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[43];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x8,0x8,0xfffffff8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x10,0x400000,0x820,0x100,0x1f800440,0x20000000,0xc0000000,0x80,0x1000,0x2000,0x8000,0x80000,0x200,0x200000,0x4000,0x10000,0x20000,0x40000,0x100000,0x8,0xffffffe0,0x8,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0xf,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[19];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public FtpParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FtpParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FtpParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public FtpParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new FtpParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public FtpParser(FtpParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(FtpParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[39];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 43; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 39; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 19; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
